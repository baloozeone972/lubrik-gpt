// =============================================================================
// File: services/cdn/CDNService.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 11:39:23 CEST 2025
// =============================================================================

import { S3Client, PutObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { CloudFrontClient, CreateInvalidationCommand } from '@aws-sdk/client-cloudfront';
import sharp from 'sharp';
import { createHash } from 'crypto';
import { lookup } from 'mime-types';

interface CDNConfig {
  s3: {
    region: string;
    bucket: string;
    accessKeyId: string;
    secretAccessKey: string;
  };
  cloudfront: {
    distributionId: string;
    domain: string;
  };
  imageOptimization: {
    formats: Array<'webp' | 'avif' | 'jpeg' | 'png'>;
    sizes: number[];
    quality: number;
  };
}

interface UploadOptions {
  contentType?: string;
  cacheControl?: string;
  metadata?: Record<string, string>;
  optimize?: boolean;
  generateSrcSet?: boolean;
}

interface OptimizedImage {
  url: string;
  format: string;
  width: number;
  height: number;
  size: number;
}

export class CDNService {
  private s3: S3Client;
  private cloudfront: CloudFrontClient;
  private config: CDNConfig;

  constructor(config: CDNConfig) {
    this.config = config;
    
    this.s3 = new S3Client({
      region: config.s3.region,
      credentials: {
        accessKeyId: config.s3.accessKeyId,
        secretAccessKey: config.s3.secretAccessKey
      }
    });

    this.cloudfront = new CloudFrontClient({
      region: config.s3.region,
      credentials: {
        accessKeyId: config.s3.accessKeyId,
        secretAccessKey: config.s3.secretAccessKey
      }
    });
  }

  async uploadFile(
    file: Buffer | Uint8Array,
    key: string,
    options: UploadOptions = {}
  ): Promise<string> {
    const contentType = options.contentType || lookup(key) || 'application/octet-stream';
    const isImage = contentType.startsWith('image/');
    
    if (isImage && options.optimize !== false) {
      return await this.uploadOptimizedImage(file, key, options);
    }

    // Generate unique key with content hash
    const hash = createHash('md5').update(file).digest('hex').substring(0, 8);
    const hashedKey = this.generateHashedKey(key, hash);

    await this.s3.send(new PutObjectCommand({
      Bucket: this.config.s3.bucket,
      Key: hashedKey,
      Body: file,
      ContentType: contentType,
      CacheControl: options.cacheControl || 'public, max-age=31536000, immutable',
      Metadata: options.metadata
    }));

    return this.getCDNUrl(hashedKey);
  }

  private async uploadOptimizedImage(
    file: Buffer | Uint8Array,
    key: string,
    options: UploadOptions
  ): Promise<string> {
    const image = sharp(file);
    const metadata = await image.metadata();
    const results: OptimizedImage[] = [];

    // Generate different formats and sizes
    const formats = this.config.imageOptimization.formats;
    const sizes = options.generateSrcSet 
      ? this.config.imageOptimization.sizes 
      : [metadata.width || 1920];

    for (const format of formats) {
      for (const width of sizes) {
        if (width > (metadata.width || 0)) continue;

        const optimized = await this.optimizeImage(image, {
          format,
          width,
          quality: this.config.imageOptimization.quality
        });

        const optimizedKey = this.generateOptimizedKey(key, format, width);
        
        await this.s3.send(new PutObjectCommand({
          Bucket: this.config.s3.bucket,
          Key: optimizedKey,
          Body: optimized.buffer,
          ContentType: `image/${format}`,
          CacheControl: 'public, max-age=31536000, immutable',
          Metadata: {
            ...options.metadata,
            originalFormat: metadata.format || '',
            width: width.toString(),
            height: optimized.height.toString()
          }
        }));

        results.push({
          url: this.getCDNUrl(optimizedKey),
          format,
          width,
          height: optimized.height,
          size: optimized.buffer.byteLength
        });
      }
    }

    // Return the most appropriate URL (WebP if available, otherwise original format)
    const preferredFormat = formats.includes('webp') ? 'webp' : formats[0];
    const preferredImage = results.find(r => r.format === preferredFormat && r.width === sizes[0]);
    
    return preferredImage?.url || this.getCDNUrl(key);
  }

  private async optimizeImage(
    image: sharp.Sharp,
    options: { format: string; width: number; quality: number }
  ): Promise<{ buffer: Buffer; height: number }> {
    let pipeline = image.resize(options.width, null, {
      withoutEnlargement: true,
      fit: 'inside'
    });

    switch (options.format) {
      case 'webp':
        pipeline = pipeline.webp({ quality: options.quality });
        break;
      case 'avif':
        pipeline = pipeline.avif({ quality: options.quality });
        break;
      case 'jpeg':
        pipeline = pipeline.jpeg({ quality: options.quality, progressive: true });
        break;
      case 'png':
        pipeline = pipeline.png({ quality: options.quality, progressive: true });
        break;
    }

    const buffer = await pipeline.toBuffer();
    const { height } = await sharp(buffer).metadata();
    
    return { buffer, height: height || 0 };
  }

  async generateSrcSet(imageUrl: string): Promise<string> {
    const key = this.getKeyFromUrl(imageUrl);
    const srcSetParts: string[] = [];

    for (const size of this.config.imageOptimization.sizes) {
      const optimizedKey = this.generateOptimizedKey(key, 'webp', size);
      const url = this.getCDNUrl(optimizedKey);
      srcSetParts.push(`${url} ${size}w`);
    }

    return srcSetParts.join(', ');
  }

  async deleteFile(key: string): Promise<void> {
    await this.s3.send(new DeleteObjectCommand({
      Bucket: this.config.s3.bucket,
      Key: key
    }));
  }

  async invalidateCache(paths: string[]): Promise<void> {
    await this.cloudfront.send(new CreateInvalidationCommand({
      DistributionId: this.config.cloudfront.distributionId,
      InvalidationBatch: {
        CallerReference: Date.now().toString(),
        Paths: {
          Quantity: paths.length,
          Items: paths
        }
      }
    }));
  }

  generateSignedUrl(key: string, expiresIn: number = 3600): string {
    // Implementation depends on CloudFront signed URLs setup
    // This is a placeholder
    return `${this.config.cloudfront.domain}/${key}?expires=${Date.now() + expiresIn * 1000}`;
  }

  private generateHashedKey(key: string, hash: string): string {
    const parts = key.split('.');
    const ext = parts.pop();
    const name = parts.join('.');
    return `${name}-${hash}.${ext}`;
  }

  private generateOptimizedKey(key: string, format: string, width: number): string {
    const parts = key.split('.');
    parts.pop(); // Remove extension
    const name = parts.join('.');
    return `${name}-${width}w.${format}`;
  }

  private getCDNUrl(key: string): string {
    return `https://${this.config.cloudfront.domain}/${key}`;
  }

  private getKeyFromUrl(url: string): string {
    return url.replace(`https://${this.config.cloudfront.domain}/`, '');
  }
}