// =============================================================================
// File: services/database/DatabaseOptimizer.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 11:39:23 CEST 2025
// =============================================================================

import { DataSource, QueryRunner } from 'typeorm';
import { performance } from 'perf_hooks';

interface QueryStats {
  query: string;
  count: number;
  totalTime: number;
  avgTime: number;
  maxTime: number;
  minTime: number;
}

interface OptimizationSuggestion {
  type: 'index' | 'query' | 'table';
  severity: 'low' | 'medium' | 'high';
  description: string;
  recommendation: string;
  estimatedImprovement: string;
}

export class DatabaseOptimizer {
  private dataSource: DataSource;
  private queryStats: Map<string, QueryStats> = new Map();
  private slowQueryThreshold: number = 100; // ms

  constructor(dataSource: DataSource) {
    this.dataSource = dataSource;
    this.setupQueryLogging();
  }

  private setupQueryLogging() {
    const originalQuery = this.dataSource.query.bind(this.dataSource);
    
    this.dataSource.query = async (query: string, parameters?: any[]) => {
      const start = performance.now();
      
      try {
        const result = await originalQuery(query, parameters);
        const duration = performance.now() - start;
        
        this.recordQueryStats(query, duration);
        
        if (duration > this.slowQueryThreshold) {
          console.warn(`Slow query detected (${duration.toFixed(2)}ms):`, query);
        }
        
        return result;
      } catch (error) {
        const duration = performance.now() - start;
        this.recordQueryStats(query, duration, true);
        throw error;
      }
    };
  }

  private recordQueryStats(query: string, duration: number, error: boolean = false) {
    const normalizedQuery = this.normalizeQuery(query);
    const stats = this.queryStats.get(normalizedQuery) || {
      query: normalizedQuery,
      count: 0,
      totalTime: 0,
      avgTime: 0,
      maxTime: 0,
      minTime: Infinity
    };

    stats.count++;
    stats.totalTime += duration;
    stats.avgTime = stats.totalTime / stats.count;
    stats.maxTime = Math.max(stats.maxTime, duration);
    stats.minTime = Math.min(stats.minTime, duration);

    this.queryStats.set(normalizedQuery, stats);
  }

  private normalizeQuery(query: string): string {
    // Remove specific values to group similar queries
    return query
      .replace(/\s+/g, ' ')
      .replace(/\d+/g, '?')
      .replace(/'[^']*'/g, '?')
      .toLowerCase()
      .trim();
  }

  async analyzePerformance(): Promise<{
    slowQueries: QueryStats[];
    suggestions: OptimizationSuggestion[];
  }> {
    const slowQueries = Array.from(this.queryStats.values())
      .filter(stats => stats.avgTime > this.slowQueryThreshold)
      .sort((a, b) => b.avgTime - a.avgTime);

    const suggestions = await this.generateOptimizationSuggestions();

    return { slowQueries, suggestions };
  }

  private async generateOptimizationSuggestions(): Promise<OptimizationSuggestion[]> {
    const suggestions: OptimizationSuggestion[] = [];
    const runner = this.dataSource.createQueryRunner();

    try {
      // Analyze missing indexes
      const missingIndexes = await this.analyzeMissingIndexes(runner);
      suggestions.push(...missingIndexes);

      // Analyze table statistics
      const tableStats = await this.analyzeTableStatistics(runner);
      suggestions.push(...tableStats);

      // Analyze query patterns
      const queryPatterns = this.analyzeQueryPatterns();
      suggestions.push(...queryPatterns);

      return suggestions.sort((a, b) => {
        const severityOrder = { high: 0, medium: 1, low: 2 };
        return severityOrder[a.severity] - severityOrder[b.severity];
      });
    } finally {
      await runner.release();
    }
  }

  private async analyzeMissingIndexes(runner: QueryRunner): Promise<OptimizationSuggestion[]> {
    const suggestions: OptimizationSuggestion[] = [];

    // PostgreSQL specific query to find missing indexes
    const missingIndexQuery = `
      SELECT 
        schemaname,
        tablename,
        attname,
        n_distinct,
        avg_width,
        correlation
      FROM pg_stats
      WHERE schemaname = 'public'
        AND n_distinct > 100
        AND correlation < 0.1
      ORDER BY n_distinct DESC
      LIMIT 10
    `;

    const results = await runner.query(missingIndexQuery);

    for (const row of results) {
      suggestions.push({
        type: 'index',
        severity: row.n_distinct > 1000 ? 'high' : 'medium',
        description: `Missing index on ${row.tablename}.${row.attname}`,
        recommendation: `CREATE INDEX idx_${row.tablename}_${row.attname} ON ${row.tablename}(${row.attname})`,
        estimatedImprovement: `${Math.round(row.n_distinct / 100)}% faster queries`
      });
    }

    return suggestions;
  }

  private async analyzeTableStatistics(runner: QueryRunner): Promise<OptimizationSuggestion[]> {
    const suggestions: OptimizationSuggestion[] = [];

    // Check for tables that need VACUUM/ANALYZE
    const tableStatsQuery = `
      SELECT 
        schemaname,
        tablename,
        n_dead_tup,
        n_live_tup,
        last_vacuum,
        last_analyze
      FROM pg_stat_user_tables
      WHERE schemaname = 'public'
        AND (n_dead_tup > n_live_tup * 0.2 
             OR last_analyze < CURRENT_DATE - INTERVAL '7 days'
             OR last_analyze IS NULL)
    `;

    const results = await runner.query(tableStatsQuery);

    for (const row of results) {
      if (row.n_dead_tup > row.n_live_tup * 0.2) {
        suggestions.push({
          type: 'table',
          severity: 'high',
          description: `Table ${row.tablename} has ${row.n_dead_tup} dead tuples`,
          recommendation: `VACUUM ANALYZE ${row.tablename}`,
          estimatedImprovement: '20-50% storage reduction'
        });
      }

      if (!row.last_analyze || new Date(row.last_analyze) < new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)) {
        suggestions.push({
          type: 'table',
          severity: 'medium',
          description: `Table ${row.tablename} statistics are outdated`,
          recommendation: `ANALYZE ${row.tablename}`,
          estimatedImprovement: 'Better query plans'
        });
      }
    }

    return suggestions;
  }

  private analyzeQueryPatterns(): OptimizationSuggestion[] {
    const suggestions: OptimizationSuggestion[] = [];

    // Check for N+1 queries
    const similarQueries = new Map<string, number>();
    
    for (const [query, stats] of this.queryStats) {
      const baseQuery = query.replace(/where.*$/i, 'where ...');
      const count = similarQueries.get(baseQuery) || 0;
      similarQueries.set(baseQuery, count + stats.count);
    }

    for (const [query, count] of similarQueries) {
      if (count > 100) {
        suggestions.push({
          type: 'query',
          severity: 'high',
          description: `Potential N+1 query pattern detected`,
          recommendation: `Consider using JOIN or batch loading for: ${query}`,
          estimatedImprovement: `${Math.round(count / 10)}x fewer queries`
        });
      }
    }

    // Check for queries without LIMIT
    for (const [query, stats] of this.queryStats) {
      if (query.includes('select') && !query.includes('limit') && stats.avgTime > 50) {
        suggestions.push({
          type: 'query',
          severity: 'medium',
          description: `Query without LIMIT clause taking ${stats.avgTime.toFixed(2)}ms`,
          recommendation: `Add LIMIT clause or pagination to: ${query}`,
          estimatedImprovement: 'Reduced memory usage'
        });
      }
    }

    return suggestions;
  }

  async optimizeDatabase(): Promise<void> {
    const runner = this.dataSource.createQueryRunner();

    try {
      // Run VACUUM ANALYZE on all tables
      console.log('Running VACUUM ANALYZE on all tables...');
      await runner.query('VACUUM ANALYZE');

      // Update table statistics
      console.log('Updating table statistics...');
      const tables = await runner.query(`
        SELECT tablename 
        FROM pg_tables 
        WHERE schemaname = 'public'
      `);

      for (const table of tables) {
        await runner.query(`ANALYZE ${table.tablename}`);
      }

      // Reindex tables with high fragmentation
      console.log('Reindexing fragmented tables...');
      const fragmentedTables = await runner.query(`
        SELECT 
          schemaname,
          tablename,
          pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS size
        FROM pg_tables
        WHERE schemaname = 'public'
          AND pg_relation_size(schemaname||'.'||tablename) > 10485760 -- 10MB
      `);

      for (const table of fragmentedTables) {
        await runner.query(`REINDEX TABLE ${table.tablename}`);
      }

      console.log('Database optimization completed');
    } finally {
      await runner.release();
    }
  }

  getQueryStats(): QueryStats[] {
    return Array.from(this.queryStats.values())
      .sort((a, b) => b.totalTime - a.totalTime);
  }

  resetStats(): void {
    this.queryStats.clear();
  }
}