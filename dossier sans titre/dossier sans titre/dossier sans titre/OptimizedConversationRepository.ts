// =============================================================================
// File: repositories/optimized/OptimizedConversationRepository.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 11:39:23 CEST 2025
// =============================================================================

import { EntityRepository, Repository, SelectQueryBuilder } from 'typeorm';
import { Conversation } from '@/entities/Conversation';
import { Message } from '@/entities/Message';

@EntityRepository(Conversation)
export class OptimizedConversationRepository extends Repository<Conversation> {
  
  // Optimized query with proper indexing and joins
  async findWithMessagesOptimized(
    userId: string,
    limit: number = 10,
    offset: number = 0
  ): Promise<Conversation[]> {
    return this.createQueryBuilder('conversation')
      .select([
        'conversation.id',
        'conversation.title',
        'conversation.lastMessageAt',
        'conversation.messageCount'
      ])
      .leftJoin('conversation.messages', 'message')
      .addSelect([
        'message.id',
        'message.content',
        'message.role',
        'message.createdAt'
      ])
      .leftJoin('conversation.character', 'character')
      .addSelect([
        'character.id',
        'character.name',
        'character.avatarUrl'
      ])
      .where('conversation.userId = :userId', { userId })
      .andWhere('conversation.deletedAt IS NULL')
      .orderBy('conversation.lastMessageAt', 'DESC')
      .take(limit)
      .skip(offset)
      .cache(`conversations:${userId}:${limit}:${offset}`, 300000) // 5 min cache
      .getMany();
  }

  // Batch loading to avoid N+1 queries
  async findWithMessagesBatch(conversationIds: string[]): Promise<Map<string, Message[]>> {
    const messages = await this.manager
      .createQueryBuilder(Message, 'message')
      .select()
      .where('message.conversationId IN (:...ids)', { ids: conversationIds })
      .orderBy('message.createdAt', 'DESC')
      .limit(100) // Limit messages per conversation
      .getMany();

    // Group messages by conversation
    const messageMap = new Map<string, Message[]>();
    for (const message of messages) {
      const conversationMessages = messageMap.get(message.conversationId) || [];
      conversationMessages.push(message);
      messageMap.set(message.conversationId, conversationMessages);
    }

    return messageMap;
  }

  // Use raw queries for complex aggregations
  async getConversationStats(userId: string): Promise<{
    totalConversations: number;
    totalMessages: number;
    avgMessagesPerConversation: number;
    mostActiveHour: number;
  }> {
    const result = await this.manager.query(`
      WITH conversation_stats AS (
        SELECT 
          COUNT(DISTINCT c.id) as total_conversations,
          COUNT(m.id) as total_messages,
          AVG(c.message_count) as avg_messages
        FROM conversations c
        LEFT JOIN messages m ON m.conversation_id = c.id
        WHERE c.user_id = $1 AND c.deleted_at IS NULL
      ),
      hourly_activity AS (
        SELECT 
          EXTRACT(HOUR FROM m.created_at) as hour,
          COUNT(*) as message_count
        FROM messages m
        JOIN conversations c ON m.conversation_id = c.id
        WHERE c.user_id = $1
        GROUP BY hour
        ORDER BY message_count DESC
        LIMIT 1
      )
      SELECT 
        cs.total_conversations,
        cs.total_messages,
        cs.avg_messages,
        ha.hour as most_active_hour
      FROM conversation_stats cs, hourly_activity ha
    `, [userId]);

    return {
      totalConversations: parseInt(result[0].total_conversations),
      totalMessages: parseInt(result[0].total_messages),
      avgMessagesPerConversation: parseFloat(result[0].avg_messages),
      mostActiveHour: parseInt(result[0].most_active_hour)
    };
  }

  // Optimized search with full-text search
  async searchConversations(
    userId: string,
    searchTerm: string,
    options: {
      limit?: number;
      offset?: number;
      characterId?: string;
      dateFrom?: Date;
      dateTo?: Date;
    } = {}
  ): Promise<Conversation[]> {
    const query = this.createQueryBuilder('conversation')
      .leftJoin('conversation.messages', 'message')
      .leftJoin('conversation.character', 'character')
      .where('conversation.userId = :userId', { userId })
      .andWhere('conversation.deletedAt IS NULL');

    // Use PostgreSQL full-text search
    if (searchTerm) {
      query.andWhere(
        `to_tsvector('english', message.content) @@ plainto_tsquery('english', :search)`,
        { search: searchTerm }
      );
    }

    if (options.characterId) {
      query.andWhere('conversation.characterId = :characterId', { 
        characterId: options.characterId 
      });
    }

    if (options.dateFrom) {
      query.andWhere('conversation.createdAt >= :dateFrom', { 
        dateFrom: options.dateFrom 
      });
    }

    if (options.dateTo) {
      query.andWhere('conversation.createdAt <= :dateTo', { 
        dateTo: options.dateTo 
      });
    }

    return query
      .select([
        'conversation.id',
        'conversation.title',
        'conversation.lastMessageAt',
        'character.id',
        'character.name',
        'character.avatarUrl'
      ])
      .addSelect(`
        ts_rank(
          to_tsvector('english', message.content),
          plainto_tsquery('english', :search)
        )
      `, 'rank')
      .orderBy('rank', 'DESC')
      .addOrderBy('conversation.lastMessageAt', 'DESC')
      .take(options.limit || 20)
      .skip(options.offset || 0)
      .getMany();
  }
}