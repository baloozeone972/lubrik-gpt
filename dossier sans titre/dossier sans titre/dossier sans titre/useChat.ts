// =============================================================================
// File: src/hooks/useChat.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 11:39:23 CEST 2025
// =============================================================================

import { useState, useEffect, useCallback } from 'react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import AsyncStorage from '@react-native-async-storage/async-storage';

import { api } from '@/services/api';
import { Message, SendMessageRequest } from '@/types/chat';
import { useWebSocket } from './useWebSocket';
import { useAuth } from './useAuth';

export function useChat(conversationId: string | null, characterId: string) {
  const queryClient = useQueryClient();
  const { user } = useAuth();
  const { sendMessage: wsSendMessage } = useWebSocket(conversationId);
  
  const [messages, setMessages] = useState<Message[]>([]);
  const [sending, setSending] = useState(false);

  // Fetch messages
  const { data: fetchedMessages, isLoading } = useQuery({
    queryKey: ['messages', conversationId],
    queryFn: async () => {
      if (!conversationId) return [];
      const response = await api.get(`/conversations/${conversationId}/messages`);
      return response.data;
    },
    enabled: !!conversationId,
  });

  // Create conversation mutation
  const createConversationMutation = useMutation({
    mutationFn: async (message: string) => {
      const response = await api.post('/conversations', {
        characterId,
        initialMessage: message,
      });
      return response.data;
    },
  });

  // Send message mutation
  const sendMessageMutation = useMutation({
    mutationFn: async ({ conversationId, message }: { conversationId: string; message: string }) => {
      const response = await api.post(`/conversations/${conversationId}/messages`, {
        content: message,
        type: 'text',
      });
      return response.data;
    },
  });

  useEffect(() => {
    if (fetchedMessages) {
      setMessages(fetchedMessages);
    }
  }, [fetchedMessages]);

  const sendMessage = useCallback(async (content: string) => {
    setSending(true);
    
    try {
      let currentConversationId = conversationId;
      
      // Create conversation if needed
      if (!currentConversationId) {
        const conversation = await createConversationMutation.mutateAsync(content);
        currentConversationId = conversation.id;
        
        // Update local state with new conversation ID
        queryClient.setQueryData(['currentConversation'], conversation);
      } else {
        // Send message
        const message = await sendMessageMutation.mutateAsync({
          conversationId: currentConversationId,
          message: content,
        });
        
        // Optimistically update UI
        setMessages(prev => [...prev, message]);
        
        // Send via WebSocket for real-time updates
        wsSendMessage({
          type: 'message',
          content,
          conversationId: currentConversationId,
        });
      }
      
      // Cache conversation locally
      await AsyncStorage.setItem(
        `conversation:${currentConversationId}`,
        JSON.stringify({ characterId, lastMessage: content })
      );
    } catch (error) {
      console.error('Failed to send message:', error);
      // Show error toast
    } finally {
      setSending(false);
    }
  }, [conversationId, characterId, wsSendMessage]);

  const sendImage = useCallback(async (imageUri: string) => {
    setSending(true);
    
    try {
      const formData = new FormData();
      formData.append('image', {
        uri: imageUri,
        type: 'image/jpeg',
        name: 'photo.jpg',
      } as any);
      
      const response = await api.post(
        `/conversations/${conversationId}/messages/image`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      );
      
      setMessages(prev => [...prev, response.data]);
    } catch (error) {
      console.error('Failed to send image:', error);
    } finally {
      setSending(false);
    }
  }, [conversationId]);

  const deleteMessage = useCallback(async (messageId: string) => {
    try {
      await api.delete(`/messages/${messageId}`);
      setMessages(prev => prev.filter(m => m.id !== messageId));
      queryClient.invalidateQueries(['messages', conversationId]);
    } catch (error) {
      console.error('Failed to delete message:', error);
    }
  }, [conversationId, queryClient]);

  const editMessage = useCallback(async (messageId: string, newContent: string) => {
    try {
      const response = await api.patch(`/messages/${messageId}`, {
        content: newContent,
      });
      
      setMessages(prev =>
        prev.map(m => (m.id === messageId ? response.data : m))
      );
    } catch (error) {
      console.error('Failed to edit message:', error);
    }
  }, []);

  return {
    messages,
    loading: isLoading,
    sending,
    sendMessage,
    sendImage,
    deleteMessage,
    editMessage,
  };
}