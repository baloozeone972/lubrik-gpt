// =============================================================================
// File: src/screens/ChatScreen.tsx
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 20:53:16 CEST 2025
// =============================================================================

import React, { useState, useRef, useCallback, useEffect } from 'react';
import {
  View,
  KeyboardAvoidingView,
  Platform,
  FlatList,
  TextInput,
  TouchableOpacity,
  Alert,
  Keyboard,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { useRoute, useNavigation } from '@react-navigation/native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withSpring,
  FadeIn,
  FadeOut,
  Layout,
} from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import * as Haptics from 'expo-haptics';
import * as ImagePicker from 'expo-image-picker';
import Voice from '@react-native-voice/voice';

import { useChat } from '@/hooks/useChat';
import { useWebSocket } from '@/hooks/useWebSocket';
import { ChatHeader } from '@/components/chat/ChatHeader';
import { MessageBubble } from '@/components/chat/MessageBubble';
import { ChatInput } from '@/components/chat/ChatInput';
import { TypingIndicator } from '@/components/chat/TypingIndicator';
import { ChatActions } from '@/components/chat/ChatActions';
import { VoiceRecorder } from '@/components/chat/VoiceRecorder';
import { Message } from '@/types/chat';
import { styles } from '@/styles/ChatStyles';

export function ChatScreen() {
  const navigation = useNavigation();
  const route = useRoute();
  const { conversationId, characterId, isNewConversation } = route.params;
  
  const flatListRef = useRef<FlatList>(null);
  const inputRef = useRef<TextInput>(null);
  const keyboardHeight = useSharedValue(0);
  
  const [message, setMessage] = useState('');
  const [isRecording, setIsRecording] = useState(false);
  const [showActions, setShowActions] = useState(false);
  
  const {
    messages,
    loading,
    sending,
    sendMessage,
    sendImage,
    deleteMessage,
    editMessage,
  } = useChat(conversationId || null, characterId);
  
  const { isTyping } = useWebSocket(conversationId);

  useEffect(() => {
    // Set up voice recognition
    Voice.onSpeechResults = onSpeechResults;
    Voice.onSpeechEnd = onSpeechEnd;
    
    return () => {
      Voice.destroy().then(Voice.removeAllListeners);
    };
  }, []);

  useEffect(() => {
    // Set up keyboard listeners
    const keyboardWillShow = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillShow' : 'keyboardDidShow',
      (e) => {
        keyboardHeight.value = withSpring(e.endCoordinates.height);
      }
    );
    
    const keyboardWillHide = Keyboard.addListener(
      Platform.OS === 'ios' ? 'keyboardWillHide' : 'keyboardDidHide',
      () => {
        keyboardHeight.value = withSpring(0);
      }
    );
    
    return () => {
      keyboardWillShow.remove();
      keyboardWillHide.remove();
    };
  }, []);

  const onSpeechResults = (e: any) => {
    setMessage(e.value[0]);
  };

  const onSpeechEnd = () => {
    setIsRecording(false);
  };

  const handleSend = useCallback(async () => {
    if (!message.trim() || sending) return;
    
    const text = message.trim();
    setMessage('');
    
    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
    await sendMessage(text);
    
    // Scroll to bottom
    setTimeout(() => {
      flatListRef.current?.scrollToEnd({ animated: true });
    }, 100);
  }, [message, sending, sendMessage]);

  const handleImagePicker = useCallback(async () => {
    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
    
    if (status !== 'granted') {
      Alert.alert(
        'Permission Required',
        'Please enable photo library access to send images.'
      );
      return;
    }
    
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
    });
    
    if (!result.canceled) {
      await sendImage(result.assets[0].uri);
    }
  }, [sendImage]);

  const handleCamera = useCallback(async () => {
    const { status } = await ImagePicker.requestCameraPermissionsAsync();
    
    if (status !== 'granted') {
      Alert.alert(
        'Permission Required',
        'Please enable camera access to take photos.'
      );
      return;
    }
    
    const result = await ImagePicker.launchCameraAsync({
      allowsEditing: true,
      aspect: [4, 3],
      quality: 0.8,
    });
    
    if (!result.canceled) {
      await sendImage(result.assets[0].uri);
    }
  }, [sendImage]);

  const handleVoiceRecord = useCallback(async () => {
    if (isRecording) {
      try {
        await Voice.stop();
        setIsRecording(false);
      } catch (error) {
        console.error('Failed to stop recording:', error);
      }
    } else {
      try {
        await Voice.start('en-US');
        setIsRecording(true);
        await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
      } catch (error) {
        console.error('Failed to start recording:', error);
        Alert.alert(
          'Voice Recognition',
          'Voice recognition is not available on this device.'
        );
      }
    }
  }, [isRecording]);

  const handleMessageLongPress = useCallback((msg: Message) => {
    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
    
    Alert.alert(
      'Message Options',
      undefined,
      [
        {
          text: 'Copy',
          onPress: () => {
            // Copy to clipboard
            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
          },
        },
        msg.role === 'user' && {
          text: 'Edit',
          onPress: () => {
            setMessage(msg.content);
            editMessage(msg.id, msg.content);
          },
        },
        msg.role === 'user' && {
          text: 'Delete',
          style: 'destructive',
          onPress: () => deleteMessage(msg.id),
        },
        {
          text: 'Cancel',
          style: 'cancel',
        },
      ].filter(Boolean)
    );
  }, [deleteMessage, editMessage]);

  const renderMessage = useCallback(({ item, index }: { item: Message; index: number }) => (
    <Animated.View
      entering={FadeIn.delay(index * 50)}
      layout={Layout.springify()}
    >
      <MessageBubble
        message={item}
        onLongPress={() => handleMessageLongPress(item)}
        showAvatar={
          index === 0 ||
          messages[index - 1]?.role !== item.role
        }
      />
    </Animated.View>
  ), [messages, handleMessageLongPress]);

  const keyboardAvoidingStyle = useAnimatedStyle(() => ({
    paddingBottom: keyboardHeight.value,
  }));

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      <ChatHeader
        character={messages[0]?.character}
        onBack={() => navigation.goBack()}
        onOptions={() => setShowActions(true)}
      />
      
      <KeyboardAvoidingView
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
        style={styles.keyboardAvoid}
        keyboardVerticalOffset={0}
      >
        <FlatList
          ref={flatListRef}
          data={messages}
          keyExtractor={(item) => item.id}
          renderItem={renderMessage}
          contentContainerStyle={styles.messageList}
          inverted
          onContentSizeChange={() => {
            flatListRef.current?.scrollToEnd({ animated: false });
          }}
          ListEmptyComponent={
            loading ? (
              <View style={styles.loadingContainer}>
                <TypingIndicator />
              </View>
            ) : null
          }
          ListFooterComponent={
            isTyping ? <TypingIndicator /> : null
          }
        />
        
        <Animated.View style={[styles.inputContainer, keyboardAvoidingStyle]}>
          <ChatInput
            ref={inputRef}
            value={message}
            onChangeText={setMessage}
            onSend={handleSend}
            onImagePress={handleImagePicker}
            onCameraPress={handleCamera}
            onVoicePress={handleVoiceRecord}
            sending={sending}
            isRecording={isRecording}
          />
        </Animated.View>
      </KeyboardAvoidingView>
      
      {showActions && (
        <ChatActions
          onClose={() => setShowActions(false)}
          onClearChat={() => {
            Alert.alert(
              'Clear Chat',
              'Are you sure you want to clear this conversation?',
              [
                { text: 'Cancel', style: 'cancel' },
                {
                  text: 'Clear',
                  style: 'destructive',
                  onPress: () => {
                    // Clear chat logic
                    setShowActions(false);
                  },
                },
              ]
            );
          }}
        />
      )}
      
      {isRecording && (
        <VoiceRecorder
          onStop={handleVoiceRecord}
          amplitude={0.5} // Would need real amplitude from Voice
        />
      )}
    </SafeAreaView>
  );
}