// =============================================================================
// File: __tests__/hooks/useCharacters.test.tsx
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 21:11:26 CEST 2025
// =============================================================================

import { renderHook, waitFor } from '@testing-library/react';
import { useCharacters } from '@/hooks/useCharacters';
import { apiClient } from '@/lib/api';

jest.mock('@/lib/api');

describe('useCharacters', () => {
  const mockCharacters = [
    { id: '1', name: 'Character 1' },
    { id: '2', name: 'Character 2' }
  ];

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('fetches characters successfully', async () => {
    (apiClient.get as jest.Mock).mockResolvedValue({
      data: { content: mockCharacters, totalElements: 2 }
    });

    const { result } = renderHook(() => useCharacters());

    expect(result.current.loading).toBe(true);

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.characters).toEqual(mockCharacters);
      expect(result.current.error).toBeNull();
    });
  });

  it('handles fetch error', async () => {
    (apiClient.get as jest.Mock).mockRejectedValue(new Error('Network error'));

    const { result } = renderHook(() => useCharacters());

    await waitFor(() => {
      expect(result.current.loading).toBe(false);
      expect(result.current.characters).toEqual([]);
      expect(result.current.error).toBe('Network error');
    });
  });

  it('filters characters correctly', async () => {
    (apiClient.get as jest.Mock).mockResolvedValue({
      data: { content: mockCharacters }
    });

    const { result } = renderHook(() => useCharacters({ 
      filter: { tag: 'AI' } 
    }));

    await waitFor(() => {
      expect(apiClient.get).toHaveBeenCalledWith(
        expect.stringContaining('tag=AI')
      );
    });
  });
});