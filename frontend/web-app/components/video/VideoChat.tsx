// =============================================================================
// File: components/video/VideoChat.tsx
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 21:11:26 CEST 2025
// =============================================================================

import React, { useEffect, useRef, useState } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Video, VideoOff, Mic, MicOff, Phone, PhoneOff,
  Monitor, MonitorOff, SwitchCamera, Users,
  Settings, Maximize, Minimize, MessageSquare
} from 'lucide-react';
import { WebRTCService } from '@/services/webrtc/WebRTCService';
import { useSocket } from '@/hooks/useSocket';
import { Button } from '@/components/ui/Button';
import { Card } from '@/components/ui/Card';
import { Avatar } from '@/components/ui/Avatar';
import { Badge } from '@/components/ui/Badge';
import { VideoStats } from './VideoStats';
import { VideoFilters } from './VideoFilters';
import { VirtualBackground } from './VirtualBackground';

interface VideoChatProps {
  roomId: string;
  userId: string;
  characterId: string;
  onEnd?: () => void;
}

export function VideoChat({ roomId, userId, characterId, onEnd }: VideoChatProps) {
  const localVideoRef = useRef<HTMLVideoElement>(null);
  const remoteVideoRef = useRef<HTMLVideoElement>(null);
  const webrtcRef = useRef<WebRTCService | null>(null);
  
  const { socket } = useSocket();
  
  const [isConnecting, setIsConnecting] = useState(true);
  const [isConnected, setIsConnected] = useState(false);
  const [videoEnabled, setVideoEnabled] = useState(true);
  const [audioEnabled, setAudioEnabled] = useState(true);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [showStats, setShowStats] = useState(false);
  const [showFilters, setShowFilters] = useState(false);
  const [connectionQuality, setConnectionQuality] = useState<'excellent' | 'good' | 'poor'>('good');
  const [activeFilter, setActiveFilter] = useState<string | null>(null);

  useEffect(() => {
    if (!socket) return;

    const initializeWebRTC = async () => {
      try {
        const webrtc = new WebRTCService(
          {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              {
                urls: 'turn:turn.example.com:3478',
                username: 'user',
                credential: 'pass'
              }
            ],
            socketUrl: process.env.NEXT_PUBLIC_SOCKET_URL!,
            roomId,
            userId
          },
          socket
        );

        webrtc.on('localStream', (stream: MediaStream) => {
          if (localVideoRef.current) {
            localVideoRef.current.srcObject = stream;
          }
        });

        webrtc.on('remoteStream', (stream: MediaStream) => {
          if (remoteVideoRef.current) {
            remoteVideoRef.current.srcObject = stream;
          }
        });

        webrtc.on('connectionState', (state: RTCPeerConnectionState) => {
          setIsConnected(state === 'connected');
          setIsConnecting(state === 'connecting' || state === 'new');
        });

        webrtc.on('videoToggled', (enabled: boolean) => {
          setVideoEnabled(enabled);
        });

        webrtc.on('audioToggled', (enabled: boolean) => {
          setAudioEnabled(enabled);
        });

        webrtc.on('screenShare', (isSharing: boolean) => {
          setIsScreenSharing(isSharing);
        });

        webrtc.on('dataChannelMessage', (data: any) => {
          // Handle data channel messages (e.g., chat, reactions)
          console.log('Data channel message:', data);
        });

        await webrtc.initialize();
        webrtcRef.current = webrtc;

        // Start monitoring connection quality
        const statsInterval = setInterval(async () => {
          const stats = await webrtc.getStats();
          if (stats) {
            updateConnectionQuality(stats);
          }
        }, 5000);

        return () => clearInterval(statsInterval);
      } catch (error) {
        console.error('Failed to initialize WebRTC:', error);
        setIsConnecting(false);
      }
    };

    initializeWebRTC();

    return () => {
      webrtcRef.current?.cleanup();
    };
  }, [socket, roomId, userId]);

  const updateConnectionQuality = (stats: any) => {
    const packetLoss = stats['inbound-rtp']?.packetsLost || 0;
    const jitter = stats['inbound-rtp']?.jitter || 0;
    
    if (packetLoss < 1 && jitter < 30) {
      setConnectionQuality('excellent');
    } else if (packetLoss < 5 && jitter < 100) {
      setConnectionQuality('good');
    } else {
      setConnectionQuality('poor');
    }
  };

  const handleToggleVideo = () => {
    const enabled = webrtcRef.current?.toggleVideo();
    if (enabled !== undefined) {
      setVideoEnabled(enabled);
    }
  };

  const handleToggleAudio = () => {
    const enabled = webrtcRef.current?.toggleAudio();
    if (enabled !== undefined) {
      setAudioEnabled(enabled);
    }
  };

  const handleShareScreen = async () => {
    if (isScreenSharing) {
      await webrtcRef.current?.stopScreenShare();
    } else {
      await webrtcRef.current?.shareScreen();
    }
  };

  const handleSwitchCamera = () => {
    webrtcRef.current?.switchCamera();
  };

  const handleEndCall = () => {
    webrtcRef.current?.cleanup();
    onEnd?.();
  };

  const handleFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen();
      setIsFullscreen(true);
    } else {
      document.exitFullscreen();
      setIsFullscreen(false);
    }
  };

  const sendReaction = (reaction: string) => {
    webrtcRef.current?.sendData({
      type: 'reaction',
      reaction,
      timestamp: Date.now()
    });
  };

  return (
    <div className={`relative ${isFullscreen ? 'fixed inset-0 z-50' : 'h-full'} bg-black`}>
      {/* Remote Video */}
      <div className="relative w-full h-full">
        <video
          ref={remoteVideoRef}
          autoPlay
          playsInline
          className="w-full h-full object-cover"
        />
        
        {isConnecting && (
          <div className="absolute inset-0 flex items-center justify-center bg-black/80">
            <div className="text-center">
              <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4" />
              <p className="text-white">Connecting...</p>
            </div>
          </div>
        )}

        {/* Connection Quality Indicator */}
        <div className="absolute top-4 left-4">
          <Badge
            variant={
              connectionQuality === 'excellent' ? 'success' :
              connectionQuality === 'good' ? 'warning' : 'destructive'
            }
            className="px-3 py-1"
          >
            <div className="flex items-center gap-2">
              <div className={`w-2 h-2 rounded-full ${
                connectionQuality === 'excellent' ? 'bg-green-500' :
                connectionQuality === 'good' ? 'bg-yellow-500' : 'bg-red-500'
              }`} />
              {connectionQuality.charAt(0).toUpperCase() + connectionQuality.slice(1)}
            </div>
          </Badge>
        </div>

        {/* Character Info */}
        <div className="absolute top-4 right-4">
          <Card className="bg-black/50 backdrop-blur-md border-white/20 p-3">
            <div className="flex items-center gap-3">
              <Avatar src="/avatars/character.jpg" size="sm" />
              <div className="text-white">
                <p className="font-medium">Luna</p>
                <p className="text-xs text-white/70">AI Companion</p>
              </div>
            </div>
          </Card>
        </div>
      </div>

      {/* Local Video (Picture-in-Picture) */}
      <motion.div
        drag
        dragConstraints={{ left: 0, right: 0, top: 0, bottom: 0 }}
        className="absolute bottom-24 right-4 w-48 h-36 rounded-lg overflow-hidden shadow-lg"
      >
        <video
          ref={localVideoRef}
          autoPlay
          playsInline
          muted
          className={`w-full h-full object-cover ${
            activeFilter ? `filter-${activeFilter}` : ''
          }`}
        />
        {!videoEnabled && (
          <div className="absolute inset-0 bg-black flex items-center justify-center">
            <VideoOff className="w-8 h-8 text-white/50" />
          </div>
        )}
      </motion.div>

      {/* Virtual Background Controls */}
      {showFilters && (
        <VirtualBackground
          onApply={(background) => setActiveFilter(background)}
          onClose={() => setShowFilters(false)}
        />
      )}

      {/* Control Bar */}
      <div className="absolute bottom-0 left-0 right-0 p-4">
        <Card className="bg-black/80 backdrop-blur-md border-white/20 p-4">
          <div className="flex items-center justify-center gap-4">
            {/* Main Controls */}
            <Button
              variant={audioEnabled ? 'secondary' : 'destructive'}
              size="lg"
              className="rounded-full w-14 h-14"
              onClick={handleToggleAudio}
            >
              {audioEnabled ? <Mic className="w-6 h-6" /> : <MicOff className="w-6 h-6" />}
            </Button>

            <Button
              variant={videoEnabled ? 'secondary' : 'destructive'}
              size="lg"
              className="rounded-full w-14 h-14"
              onClick={handleToggleVideo}
            >
              {videoEnabled ? <Video className="w-6 h-6" /> : <VideoOff className="w-6 h-6" />}
            </Button>

            <Button
              variant="destructive"
              size="lg"
              className="rounded-full w-16 h-16"
              onClick={handleEndCall}
            >
              <PhoneOff className="w-6 h-6" />
            </Button>

            {/* Additional Controls */}
            <div className="flex items-center gap-2 ml-8">
              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
                onClick={handleShareScreen}
              >
                {isScreenSharing ? <MonitorOff className="w-5 h-5" /> : <Monitor className="w-5 h-5" />}
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
                onClick={handleSwitchCamera}
              >
                <SwitchCamera className="w-5 h-5" />
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
                onClick={() => setShowFilters(!showFilters)}
              >
                <Settings className="w-5 h-5" />
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
                onClick={() => setShowStats(!showStats)}
              >
                <Activity className="w-5 h-5" />
              </Button>

              <Button
                variant="ghost"
                size="sm"
                className="text-white hover:bg-white/20"
                onClick={handleFullscreen}
              >
                {isFullscreen ? <Minimize className="w-5 h-5" /> : <Maximize className="w-5 h-5" />}
              </Button>
            </div>
          </div>

          {/* Quick Reactions */}
          <div className="flex items-center justify-center gap-2 mt-4">
            {['👍', '❤️', '😂', '😮', '👏'].map((emoji) => (
              <Button
                key={emoji}
                variant="ghost"
                size="sm"
                className="text-2xl hover:scale-125 transition-transform"
                onClick={() => sendReaction(emoji)}
              >
                {emoji}
              </Button>
            ))}
          </div>
        </Card>
      </div>

      {/* Stats Overlay */}
      {showStats && <VideoStats webrtc={webrtcRef.current} />}
    </div>
  );
}