// =============================================================================
// File: services/ai/VideoGenerationService.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 21:11:26 CEST 2025
// =============================================================================

import { EventEmitter } from 'events';

interface VideoGenerationConfig {
  apiUrl: string;
  apiKey: string;
  model: 'animatediff' | 'stable-video-diffusion';
}

interface GenerationRequest {
  prompt: string;
  negativePrompt?: string;
  width?: number;
  height?: number;
  fps?: number;
  duration?: number; // seconds
  seed?: number;
  guidanceScale?: number;
  numInferenceSteps?: number;
  motionBucketId?: number; // For AnimateDiff
}

interface GenerationProgress {
  stage: 'queued' | 'processing' | 'encoding' | 'complete' | 'error';
  progress: number;
  eta?: number;
  preview?: string;
}

export class VideoGenerationService extends EventEmitter {
  private config: VideoGenerationConfig;
  private activeJobs: Map<string, AbortController> = new Map();

  constructor(config: VideoGenerationConfig) {
    super();
    this.config = config;
  }

  async generateVideo(request: GenerationRequest): Promise<string> {
    const jobId = this.generateJobId();
    const abortController = new AbortController();
    this.activeJobs.set(jobId, abortController);

    try {
      // Initialize generation
      const response = await fetch(`${this.config.apiUrl}/generate`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          ...request,
          model: this.config.model,
          jobId
        }),
        signal: abortController.signal
      });

      if (!response.ok) {
        throw new Error(`Generation failed: ${response.statusText}`);
      }

      const { taskId } = await response.json();

      // Poll for progress
      return await this.pollForCompletion(taskId, jobId, abortController.signal);
    } catch (error) {
      this.activeJobs.delete(jobId);
      throw error;
    }
  }

  async generateFromImage(
    imageUrl: string,
    request: Partial<GenerationRequest>
  ): Promise<string> {
    const jobId = this.generateJobId();
    const abortController = new AbortController();
    this.activeJobs.set(jobId, abortController);

    try {
      const response = await fetch(`${this.config.apiUrl}/img2video`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.config.apiKey}`
        },
        body: JSON.stringify({
          imageUrl,
          ...request,
          model: this.config.model,
          jobId
        }),
        signal: abortController.signal
      });

      if (!response.ok) {
        throw new Error(`Generation failed: ${response.statusText}`);
      }

      const { taskId } = await response.json();
      return await this.pollForCompletion(taskId, jobId, abortController.signal);
    } catch (error) {
      this.activeJobs.delete(jobId);
      throw error;
    }
  }

  private async pollForCompletion(
    taskId: string,
    jobId: string,
    signal: AbortSignal
  ): Promise<string> {
    const pollInterval = 2000; // 2 seconds
    let attempts = 0;
    const maxAttempts = 300; // 10 minutes max

    while (attempts < maxAttempts) {
      if (signal.aborted) {
        throw new Error('Generation cancelled');
      }

      const statusResponse = await fetch(
        `${this.config.apiUrl}/status/${taskId}`,
        {
          headers: {
            'Authorization': `Bearer ${this.config.apiKey}`
          },
          signal
        }
      );

      if (!statusResponse.ok) {
        throw new Error(`Status check failed: ${statusResponse.statusText}`);
      }

      const status = await statusResponse.json();

      const progress: GenerationProgress = {
        stage: status.stage,
        progress: status.progress || 0,
        eta: status.eta,
        preview: status.preview
      };

      this.emit('progress', { jobId, ...progress });

      if (status.stage === 'complete') {
        this.activeJobs.delete(jobId);
        return status.videoUrl;
      }

      if (status.stage === 'error') {
        this.activeJobs.delete(jobId);
        throw new Error(status.error || 'Generation failed');
      }

      await new Promise(resolve => setTimeout(resolve, pollInterval));
      attempts++;
    }

    throw new Error('Generation timeout');
  }

  async enhanceVideo(
    videoUrl: string,
    options: {
      upscale?: boolean;
      stabilize?: boolean;
      interpolate?: boolean;
      targetFps?: number;
    }
  ): Promise<string> {
    const response = await fetch(`${this.config.apiUrl}/enhance`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.config.apiKey}`
      },
      body: JSON.stringify({
        videoUrl,
        ...options
      })
    });

    if (!response.ok) {
      throw new Error(`Enhancement failed: ${response.statusText}`);
    }

    const { taskId } = await response.json();
    return await this.pollForCompletion(taskId, this.generateJobId(), new AbortController().signal);
  }

  cancelGeneration(jobId: string) {
    const controller = this.activeJobs.get(jobId);
    if (controller) {
      controller.abort();
      this.activeJobs.delete(jobId);
      this.emit('cancelled', { jobId });
    }
  }

  private generateJobId(): string {
    return `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}