// =============================================================================
// File: services/webrtc/WebRTCService.ts
// Generated by TypeScriptFileParser
// Date: Thu Jun 19 21:11:26 CEST 2025
// =============================================================================

import { EventEmitter } from 'events';
import { Socket } from 'socket.io-client';

interface WebRTCConfig {
  iceServers: RTCIceServer[];
  socketUrl: string;
  roomId: string;
  userId: string;
}

interface MediaConstraints {
  video: boolean | MediaTrackConstraints;
  audio: boolean | MediaTrackConstraints;
}

export class WebRTCService extends EventEmitter {
  private pc: RTCPeerConnection | null = null;
  private socket: Socket;
  private localStream: MediaStream | null = null;
  private remoteStream: MediaStream | null = null;
  private config: WebRTCConfig;
  private isInitiator: boolean = false;
  private dataChannel: RTCDataChannel | null = null;

  constructor(config: WebRTCConfig, socket: Socket) {
    super();
    this.config = config;
    this.socket = socket;
    this.setupSocketListeners();
  }

  async initialize(constraints: MediaConstraints = { video: true, audio: true }) {
    try {
      // Get user media
      this.localStream = await navigator.mediaDevices.getUserMedia(constraints);
      this.emit('localStream', this.localStream);

      // Create peer connection
      this.pc = new RTCPeerConnection({
        iceServers: this.config.iceServers
      });

      // Add local stream tracks
      this.localStream.getTracks().forEach(track => {
        this.pc!.addTrack(track, this.localStream!);
      });

      // Setup peer connection listeners
      this.setupPeerConnectionListeners();

      // Join room
      this.socket.emit('join-room', {
        roomId: this.config.roomId,
        userId: this.config.userId
      });

      return this.localStream;
    } catch (error) {
      console.error('Failed to initialize WebRTC:', error);
      this.emit('error', error);
      throw error;
    }
  }

  private setupSocketListeners() {
    this.socket.on('user-joined', async (data: { userId: string }) => {
      if (data.userId !== this.config.userId) {
        this.isInitiator = true;
        await this.createOffer();
      }
    });

    this.socket.on('offer', async (data: { offer: RTCSessionDescriptionInit, from: string }) => {
      if (!this.pc) await this.initialize();
      
      await this.pc!.setRemoteDescription(data.offer);
      const answer = await this.pc!.createAnswer();
      await this.pc!.setLocalDescription(answer);
      
      this.socket.emit('answer', {
        answer,
        to: data.from,
        roomId: this.config.roomId
      });
    });

    this.socket.on('answer', async (data: { answer: RTCSessionDescriptionInit }) => {
      if (this.pc?.signalingState === 'have-local-offer') {
        await this.pc.setRemoteDescription(data.answer);
      }
    });

    this.socket.on('ice-candidate', async (data: { candidate: RTCIceCandidateInit }) => {
      if (this.pc?.remoteDescription) {
        await this.pc.addIceCandidate(data.candidate);
      }
    });

    this.socket.on('user-left', (data: { userId: string }) => {
      if (data.userId !== this.config.userId) {
        this.cleanup();
        this.emit('user-left', data.userId);
      }
    });
  }

  private setupPeerConnectionListeners() {
    if (!this.pc) return;

    this.pc.onicecandidate = (event) => {
      if (event.candidate) {
        this.socket.emit('ice-candidate', {
          candidate: event.candidate,
          roomId: this.config.roomId
        });
      }
    };

    this.pc.ontrack = (event) => {
      if (!this.remoteStream) {
        this.remoteStream = new MediaStream();
        this.emit('remoteStream', this.remoteStream);
      }
      this.remoteStream.addTrack(event.track);
    };

    this.pc.onconnectionstatechange = () => {
      this.emit('connectionState', this.pc?.connectionState);
      
      if (this.pc?.connectionState === 'connected') {
        this.setupDataChannel();
      }
    };

    this.pc.oniceconnectionstatechange = () => {
      this.emit('iceConnectionState', this.pc?.iceConnectionState);
    };
  }

  private setupDataChannel() {
    if (this.isInitiator && this.pc) {
      this.dataChannel = this.pc.createDataChannel('chat');
      this.setupDataChannelListeners();
    } else if (this.pc) {
      this.pc.ondatachannel = (event) => {
        this.dataChannel = event.channel;
        this.setupDataChannelListeners();
      };
    }
  }

  private setupDataChannelListeners() {
    if (!this.dataChannel) return;

    this.dataChannel.onopen = () => {
      this.emit('dataChannelOpen');
    };

    this.dataChannel.onmessage = (event) => {
      this.emit('dataChannelMessage', JSON.parse(event.data));
    };

    this.dataChannel.onerror = (error) => {
      this.emit('dataChannelError', error);
    };
  }

  async createOffer() {
    if (!this.pc) throw new Error('Peer connection not initialized');

    const offer = await this.pc.createOffer();
    await this.pc.setLocalDescription(offer);
    
    this.socket.emit('offer', {
      offer,
      roomId: this.config.roomId
    });
  }

  sendData(data: any) {
    if (this.dataChannel?.readyState === 'open') {
      this.dataChannel.send(JSON.stringify(data));
    }
  }

  toggleVideo(enabled?: boolean) {
    const videoTrack = this.localStream?.getVideoTracks()[0];
    if (videoTrack) {
      videoTrack.enabled = enabled ?? !videoTrack.enabled;
      this.emit('videoToggled', videoTrack.enabled);
      return videoTrack.enabled;
    }
    return false;
  }

  toggleAudio(enabled?: boolean) {
    const audioTrack = this.localStream?.getAudioTracks()[0];
    if (audioTrack) {
      audioTrack.enabled = enabled ?? !audioTrack.enabled;
      this.emit('audioToggled', audioTrack.enabled);
      return audioTrack.enabled;
    }
    return false;
  }

  async switchCamera() {
    if (!this.localStream) return;

    const videoTrack = this.localStream.getVideoTracks()[0];
    if (!videoTrack) return;

    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      
      if (videoDevices.length <= 1) return;

      const currentDeviceId = videoTrack.getSettings().deviceId;
      const currentIndex = videoDevices.findIndex(device => device.deviceId === currentDeviceId);
      const nextIndex = (currentIndex + 1) % videoDevices.length;
      const nextDevice = videoDevices[nextIndex];

      const newStream = await navigator.mediaDevices.getUserMedia({
        video: { deviceId: nextDevice.deviceId },
        audio: false
      });

      const newVideoTrack = newStream.getVideoTracks()[0];
      const sender = this.pc?.getSenders().find(s => s.track?.kind === 'video');
      
      if (sender) {
        await sender.replaceTrack(newVideoTrack);
      }

      videoTrack.stop();
      this.localStream.removeTrack(videoTrack);
      this.localStream.addTrack(newVideoTrack);

      this.emit('cameraSwitch', nextDevice);
    } catch (error) {
      console.error('Failed to switch camera:', error);
      this.emit('error', error);
    }
  }

  async shareScreen() {
    try {
      const screenStream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: false
      });

      const screenTrack = screenStream.getVideoTracks()[0];
      const sender = this.pc?.getSenders().find(s => s.track?.kind === 'video');

      if (sender) {
        await sender.replaceTrack(screenTrack);
      }

      screenTrack.onended = () => {
        this.stopScreenShare();
      };

      this.emit('screenShare', true);
      return screenStream;
    } catch (error) {
      console.error('Failed to share screen:', error);
      this.emit('error', error);
      throw error;
    }
  }

  async stopScreenShare() {
    const videoTrack = this.localStream?.getVideoTracks()[0];
    if (!videoTrack) return;

    const sender = this.pc?.getSenders().find(s => s.track?.kind === 'video');
    if (sender) {
      await sender.replaceTrack(videoTrack);
    }

    this.emit('screenShare', false);
  }

  getStats() {
    if (!this.pc) return Promise.resolve(null);

    return this.pc.getStats().then(stats => {
      const report: any = {};
      stats.forEach((stat) => {
        if (stat.type === 'inbound-rtp' || stat.type === 'outbound-rtp') {
          report[stat.type] = {
            packetsLost: stat.packetsLost,
            jitter: stat.jitter,
            roundTripTime: stat.roundTripTime,
            bytesReceived: stat.bytesReceived,
            bytesSent: stat.bytesSent
          };
        }
      });
      return report;
    });
  }

  cleanup() {
    this.localStream?.getTracks().forEach(track => track.stop());
    this.remoteStream?.getTracks().forEach(track => track.stop());
    
    if (this.dataChannel) {
      this.dataChannel.close();
      this.dataChannel = null;
    }
    
    if (this.pc) {
      this.pc.close();
      this.pc = null;
    }

    this.localStream = null;
    this.remoteStream = null;
    
    this.socket.emit('leave-room', {
      roomId: this.config.roomId,
      userId: this.config.userId
    });

    this.removeAllListeners();
  }
}